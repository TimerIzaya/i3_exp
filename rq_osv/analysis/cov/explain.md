# 图例

## GM_FULL

50%的实例负责代码生成，50%的实例负责代码变异，其中变异包含50%的os数据变异和ir结构变异

## GM_IR

50%的实例负责代码生成，50%的实例负责代码变异，其中变异全为ir结构变异

## GM_OS

50%的实例负责代码生成，50%的实例负责代码变异，其中变异全为os结构变异

# 分析

## 前提

1. IR变异的过程中，由于要保证局部修改节点的上下文一致性，必须要对其进行一次完全的emit，也就是重新把整个optTree翻译成IR，再从IR翻译成JS，所以IR变异是一个比较重量级的操作，我们尽可能的一次变异多处内容，保证变异的高效
2. OS变异的过程中，需要把interesting value写入到osv_pool中，写入操作相比读操作消耗更多的时间，所以前期在osv_pool构建的时候，磁盘负载较大，耗时更久，fuzzing后期逐渐会变为：生成出的value很难有趣，绝大部分的情况都是从osv_pool中随机挑选value进行填充

## 折线图分析

GM_FULL从结果来看，在24h内能触发更多的新边，但是前期爬升速度较为缓慢，因为该版本包含了所有类型的变异，所以fuzzer整体负载较大，覆盖率爬升较为缓慢，但是从后期看，由于前期完善了corpus和osv_pool的构建，该版本具备更大的探索空间，上限更高。

GM_IR从结果来看，因为最小化机制把入库的代码尽可能的精简，相比纯Gen模式带来的更多冗余节点生成，IR变异前期效率更高是，更容易触发新边，但是IDB整体是数据导向的被测对象，纯api层面的变异上限很低，所以在24h实验中该版本最终的局部收敛结果最差。

 GM_OS从结果来看，前期爬升相比GM_IR更缓慢，因为osv_pool的构建前期执行大量写操作，负载较高，该版本下最终生成的osv_pool大小为2.4G，包含677个interesting value，由此可以证明IDB属于数据导向的被测对象，对数据进行变异性价比更高。







































